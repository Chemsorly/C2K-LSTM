in
classic
timediff = int(row[3]) #col 4 is calculated time since last event
timediff2 = int(row[4]) #col 5 is timestamp aka time since case start
timediff3 = int(row[2]) #col 3 is duration
timediff4 = int(row[5]) #col 6 is planned duration
timediff5 = int(row[6]) #col 7 is planned timestamp

s2e specific:
timediff6 = int(row[8]) #col 9 is end timestamp
timediff7 = int(row[9]) #col 10 is planned end timestamp

rgb
timediff = int(row[3]) #col 4 is calculated time since last event
timediff2 = int(row[4]) #col 5 is timestamp aka time since case start
timediff3 = int(row[2]) #col 3 is duration
timediff4 = int(row[5]) #col 6 is planned duration
timediff5 = int(row[6]) #col 7 is planned timestamp
timediff6 = int(row[8]) #col 9 is end timestamp
timediff7 = int(row[11]) #col 12 is planned end timestamp

numeric
X = { x_a=[onehot],x_t=[time since last event, timestamp, duration, planned duration, planned timestamp] }
Y = { y_a=[onehot(softmax)], y_t = [time since last event, timestamp, duration, planned duration, planned timestamp] }

binary
extra violation layer y_v
X = { x_a=[onehot],x_t=[time since last event, timestamp, duration, planned duration, planned timestamp], x_v[timestamp > planned timestamp] }
Y = { y_a=[onehot(softmax)], y_t = [time since last event, timestamp, duration, planned duration, planned timestamp], y_v[violation(sigmoid)] }
violation = third output layer prediction
'violation_output':'binary_crossentropy'

s2s
sumprevious = sum(prefix time since last event) + sum(suffix time since last event)
timestamp = predicted timestamp.last()

s2e
X = { x_a=[onehot],x_t=[time since last event, timestamp, duration, planned duration, planned timestamp] }
Y = { y_a=[onehot(softmax)], y_t = [end timestamp] }
sumprevious = do not use, since it does not do s2s
timestamp = predicted timestamp.last()